#include <Gamebuino-Meta.h>

#include "Drawing.h"

#include "Globals.h"
#include "Utils.h"

void drawLines(int i) {
  gb.display.drawLine(8 + i * 7, 0, 8 + i * 7, 63);
  gb.display.drawLine(8, i * 7, 71, i * 7);
}

void drawCell(int x, int y) {
  gb.display.fillRect(9 + x * 7, 1 + y * 7, 6, 6);
}

void drawValue(int x, int y, int value) {
  gb.display.setCursor(x * 7 + 11, y * 7 + 2);
  gb.display.print(value);
}

int solvedCount;

const uint8_t solveImageData[] = {
  74, 9, 1, 0, 1, 0xFF, 1,
  0x00, 0x0a, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0xcc, 0x00, 0x00,
  0xcc, 0x0c, 0xcc, 0xcc, 0xc0, 0xcc, 0x00, 0x00, 0xcc, 0x00,
  0x00, 0x00, 0xbb, 0xbb, 0x00, 0x00, 0xbb, 0xbb, 0x00, 0xbb,
  0x00, 0xbb, 0x0b, 0xbb, 0xbb, 0xb0, 0xaa,
  0x00, 0xaa, 0xaa, 0xaa, 0xa0, 0x00, 0x00, 0xcc, 0x00, 0x00,
  0xcc, 0x0c, 0xcc, 0xcc, 0xc0, 0xcc, 0x00, 0x00, 0xcc, 0x00,
  0x00, 0x00, 0xbb, 0xbb, 0xb0, 0x0b, 0xbb, 0xbb, 0xb0, 0xbb,
  0xb0, 0xbb, 0x0b, 0xbb, 0xbb, 0xb0, 0xaa,
  0x0a, 0xaa, 0x0a, 0x0a, 0xaa, 0x00, 0x00, 0xcc, 0x00, 0x00,
  0xcc, 0x0c, 0xc0, 0x00, 0x00, 0xcc, 0x00, 0x00, 0xcc, 0x00,
  0x00, 0x00, 0xbb, 0x0b, 0xbb, 0x0b, 0xb0, 0x0b, 0xb0, 0xbb,
  0xbb, 0xbb, 0x0b, 0xb0, 0x00, 0x00, 0xaa,
  0x0a, 0xaa, 0x0a, 0x0a, 0xaa, 0x00, 0x00, 0xcc, 0x0c, 0xc0,
  0xcc, 0x0c, 0xcc, 0xc0, 0x00, 0xcc, 0x00, 0x00, 0xcc, 0x00,
  0x00, 0x00, 0xbb, 0x00, 0xbb, 0x0b, 0xb0, 0x0b, 0xb0, 0xbb,
  0xbb, 0xbb, 0x0b, 0xbb, 0xb0, 0x00, 0xaa,
  0x0a, 0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0xcc, 0x0c, 0xc0,
  0xcc, 0x0c, 0xcc, 0xc0, 0x00, 0xcc, 0x00, 0x00, 0xcc, 0x00,
  0x00, 0x00, 0xbb, 0x00, 0xbb, 0x0b, 0xb0, 0x0b, 0xb0, 0xbb,
  0x0b, 0xbb, 0x0b, 0xbb, 0xb0, 0x00, 0xaa,
  0x0a, 0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0xcc, 0x0c, 0xc0,
  0xcc, 0x0c, 0xcc, 0xc0, 0x00, 0xcc, 0x00, 0x00, 0xcc, 0x00,
  0x00, 0x00, 0xbb, 0x00, 0xbb, 0x0b, 0xb0, 0x0b, 0xb0, 0xbb,
  0x00, 0xbb, 0x0b, 0xbb, 0xb0, 0x00, 0xaa,
  0x0a, 0xa0, 0x00, 0x00, 0xaa, 0x00, 0x00, 0xcc, 0x0c, 0xc0,
  0xcc, 0x0c, 0xc0, 0x00, 0x00, 0xcc, 0x00, 0x00, 0xcc, 0x00,
  0x00, 0x00, 0xbb, 0x0b, 0xbb, 0x0b, 0xb0, 0x0b, 0xb0, 0xbb,
  0x00, 0xbb, 0x0b, 0xb0, 0x00, 0x00, 0x00,
  0x00, 0xaa, 0x00, 0x0a, 0xa0, 0x00, 0x00, 0x0c, 0xcc, 0xcc,
  0xc0, 0x0c, 0xcc, 0xcc, 0xc0, 0xcc, 0xcc, 0xc0, 0xcc, 0xcc,
  0xc0, 0x00, 0xbb, 0xbb, 0xb0, 0x0b, 0xbb, 0xbb, 0xb0, 0xbb,
  0x00, 0xbb, 0x0b, 0xbb, 0xbb, 0xb0, 0xaa,
  0x00, 0x0a, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0x0c, 0xc0, 0x0c,
  0xc0, 0x0c, 0xcc, 0xcc, 0xc0, 0xcc, 0xcc, 0xc0, 0xcc, 0xcc,
  0xc0, 0x00, 0xbb, 0xbb, 0x00, 0x00, 0xbb, 0xbb, 0x00, 0xbb,
  0x00, 0xbb, 0x0b, 0xbb, 0xbb, 0xb0, 0xaa
};
Image solveImage = Image(solveImageData);

ColorIndex solvedColor(int col, int row) {
  int x = col + solvedCount / 4 - 12;
  if (x < 0 || x >= 74) {
    return INDEX_BLACK;
  }
  return solveImage.getPixelIndex(x, row);
}

//------------------------------------------------------------------------------

/* Light color gradients.
 *
 * These vary from black to respective GB Yellow, GB Light Blue, and GB Light
 * Green in 13 steps. The gradients have been created using
 * http://www.perbang.dk/rgbgradient/.
 *
 * The resulting RGB colors have been programmatically converted using
 * gb.createColor to the arrays with RGB565 values below.
 */
const uint8_t numGradientColors = 13;
const uint16_t gradientColorsYellow[numGradientColors] = {
  0x0000, 0x1080, 0x2920, 0x39c0, 0x5260, 0x6300, 0x7b80, 0x8c20,
  0xa4c0, 0xb560, 0xce00, 0xde80, 0xf720
};
const uint16_t gradientColorsLightBlue[numGradientColors] = {
  0x0000, 0x0862, 0x10e5, 0x1967, 0x29ea, 0x326d, 0x3aef, 0x4b72,
  0x53f5, 0x5c77, 0x6cda, 0x755d, 0x7ddf
};
const uint16_t gradientColorsLightGreen[numGradientColors] = {
  0x0000, 0x0880, 0x1101, 0x2182, 0x2a23, 0x32a4, 0x4325, 0x4bc6,
  0x5c47, 0x64c8, 0x6d69, 0x7dea, 0x866b
};

Color solveColorForLight(int x, int y) {
  int col = (x == 0) ? -2 : 9;
  int row0 = y * 2;
  ColorIndex color = INDEX_BLACK;
  int intensity = 0;

  for (int i = 0; i < 2; i++) {
    int intensityDelta = (solvedCount % 4);
    if (i == 0) {
      intensityDelta = 4 - intensityDelta;
    }
    for (int j = 0; j < 3; j++) {
      ColorIndex c = solvedColor(col + i, row0 + j);
      if (c != INDEX_BLACK) {
        color = c;
        intensity += intensityDelta;
      }
    }
  }
  assertTrue(intensity >= 0 && intensity < numGradientColors);
  if (color == INDEX_YELLOW) {
    return (Color)gradientColorsYellow[intensity];
  }
  if (color == INDEX_LIGHTBLUE) {
    return (Color)gradientColorsLightBlue[intensity];
  }
  if (color == INDEX_LIGHTGREEN) {
    return (Color)gradientColorsLightGreen[intensity];
  }
  return BLACK;
}

void drawSolveLights() {
  for (int x = 0; x < 2; x++) {
    for (int y = 0; y < 4; y++) {
      gb.lights.drawPixel(x, y, solveColorForLight(x, y));
    }
  }
}

void draw(Sudoku& sudoku) {
  gb.display.setColor(DARKGRAY);
  for (int i = 0; i <= numCols; i++) {
    if (i % 3 != 0) {
      drawLines(i);
    }
  }
  gb.display.setColor(GRAY);
  for (int i = 0; i <= numCols; i += 3) {
    drawLines(i);
  }

  if (sudoku.isSolved()) {
    solvedCount = 1 + solvedCount % 360;
    drawSolveLights();
  } else {
    solvedCount = 0;

    gb.display.setColor(BLUE);
    drawCell(cursorX, cursorY);
  }

  for (int x = 0; x < numCols; x++) {
    for (int y = 0; y < numRows; y++) {
      if (solvedCount > 0) {
        ColorIndex color = solvedColor(x, y);
        if (color != INDEX_BLACK) {
          gb.display.setColor(color);
          drawCell(x, y);
        }
      }
      if (sudoku.isSet(x, y)) {
        if (solutionCount == SolutionCount::Multiple) {
          gb.display.setColor(LIGHTGREEN);
        }
        else if (solutionCount == SolutionCount::None) {
          gb.display.setColor(RED);
        }
        else if (sudoku.isFixed(x, y)) {
          gb.display.setColor(WHITE);
        }
        else {
          gb.display.setColor(LIGHTBLUE);
        }
        drawValue(x, y, sudoku.getValue(x, y));
      }
    }
  }
}
